# GeeCache

- GeeCache是一个小巧的kv存储库，和应用程序运行在同一空间。
- 最大的特点就是没有删除接口， 即kv键值一旦设置进去了，用户端是没有主动的手段删除这个值的。 这个值将不能被用户修改，k的v不能被修改。
- 带来的好处就是没有覆盖更新带来的一致性问题。 
- 可以理解为一种分布式的采用读穿策略的缓存框架。（Redis、Memcached等缓存框架都不提供写入数据库和自动加载数据库中的数据的功能。）
- 用于热点快讯，出现之时他就会固定，而且是将会被高频访问；缓存高频访问的静态文件...


### 实现特性

- 单机缓存和基于HTTP的分布式缓存 
- 使用最近最少访问（LRU）缓存策略 
- 使用Go锁机制防止缓存击穿
- 使用一致性哈希选择节点，实现负载均衡 
- 使用protobuf优化节点间二进制通信


### TODO

- 热点数据多节点备份
  - 针对每个节点，除了会缓存本节点存在且大量访问的key之外，也会缓存那些不属于节点的(但是被频繁访问)的key。
  - 每一个缓存节点（Group）有两个缓存实体：mainCache、hotCache。mainCache主要用来存放应该存放在本缓存节点的数据。hotCache用来存放热点数据
  - 实现上：每次从其他缓存节点获取数据后，都有一定的概率(rand.Intn(10) == 0)将该数据存放到hotCache中供下一次调用，减少了HTTP通信。
  - mainCache和hotCache的缓存大小比例是8:1的比例。即需要驱逐旧数据的时候，判断hotBytes > mainBytes/8 如果成立则驱逐hotCache，否则驱逐mainCache。
- 解决缓存雪崩，缓存穿透，缓存击穿问题
  - 缓存雪崩：一致性哈希
  - 缓存击穿：singleFlight
  - 缓存穿透：对于数据库中不存在的数据，在缓存中设置值标记
- 数据一致性
  - 读穿策略的缓存框架保证数据一致性，不被修改
- 节点添加和删除
  - 使用etcd租客模式来缓存我们的所有节点IP（每启动一个服务都获取自己IP并注册到etcd，注意同一集群前缀相同）
  - 不断地获取前缀相同的key并进行对应节点IP获取，并不断监听Key的变化在根据变化不断更新上文的节点选择器。
  - 客户端申请一个租约并设置过期时间，每隔一段时间请求etcd申请续租。如果过期了，etcd 会删除这个租约上的所有key-value
- 使用grpc实现分布式节点间的相互访问
  - 微服务之间采用grpc框架，实现远程服务调用
- 实现server端和client端
  - 实现server用于监听用户请求，client端用于测试


### 整体框架
![](https://cdn.jsdelivr.net/gh/KylinLzw/MarkdownImage/img/20230829151732.png)


### 整体流程

![](https://cdn.jsdelivr.net/gh/KylinLzw/MarkdownImage/img/20230829152311.png)

